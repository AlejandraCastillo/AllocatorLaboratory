# üå± The Origin

[‚¨ÖÔ∏è Back to index](../journal_index.md)  
[üåê Ver esta entrada en espa√±ol](../../es/entries/2025-07-00_allolab.es.md)

## üå± Discovering Myself Through Allocator Laboratory

I spent a long time trying to break into the job market as an Android developer, but it was always difficult because I struggled to sit down and code, and to look for job openings. Fortunately, little by little, I managed to create a space and a set of strategies that allowed me to move forward. I learned Kotlin and Compose easily, but whenever I faced the challenge of learning a specialized library like Retrofit or Jetpack-MVVM, I would get stuck and avoid it by focusing on other things, like understanding SOLID or learning how to write unit tests. I even learned how to use MVVM as an architecture in an attempt to create a more comfortable foundation from which to approach specialized libraries.

Over time, I realized my struggles came from my need to understand everything in depth. For me, using those libraries felt like trying to work from inside a black box‚Äîone I couldn‚Äôt use until I had lit up all of its internal components. But most people don‚Äôt face it that way: they‚Äôre outside the box and can use it without a problem. I changed my learning strategy and made sure I understood everything until I felt satisfied. That change was incredibly nourishing, though I still preferred to consolidate my architectural understanding over learning new libraries.

Recently, I discovered that I‚Äôm autistic. This kind of discovery forces you to look inward and reevaluate things you once took as obvious and natural. I realized I had been job hunting with neurotypical strategies that were sabotaging me, and that I had a tendency to undervalue my knowledge just because I didn‚Äôt understand it as deeply as I wanted, or because I believed it was too basic or common to even mention. I realized that the invisible force I had to fight every day before I could sit down and work came from a lack of self-awareness‚Äîabout myself and about my neurotype.

Understanding this forced me to change my approach. In the process, I learned about the executive dysfunctions that are so common in neurodivergent people, and I created strategies to deal with them. This improved my life in many ways and made me more productive. I also realized that, contrary to what I believed, I hadn‚Äôt wasted years doing nothing. The tools I built during that time‚Äîboth technical and personal‚Äîare now my greatest professional strengths.

However, when I looked into job openings within neuroinclusion programs, I didn‚Äôt find any that fit the profile I thought I had. Thinking I had nothing to lose, I started looking into other roles‚Äîand I came across a profile I had completely ruled out before, simply due to a lack of understanding: low-level systems developer.

As I read more about it and did more research, I started getting excited. This wasn‚Äôt just a fallback option‚Äîit was something genuinely thrilling. I realized that there was a space where I could still program in C, my first programming language, and the one I always felt most comfortable with. I remembered how, during college, I delayed adopting a high-level language for as long as I could‚ÄîI was simply too comfortable with C. Object-oriented programming had always intimidated me, and I didn‚Äôt know why at the time. I could use it just fine, but it never quite felt right.

I also remembered my first semesters in college, when we studied low-level topics that fascinated me and made me fall in love with my degree. But as I advanced, all of that started fading away. One day, I found myself wondering what had made me love computing so much in the first place‚Äîwondering where that spark had gone. I even began questioning whether I had chosen the right career.

Now, looking back, I realize that I was never meant for high-level programming, with its black boxes and its seemingly more ‚Äúfriendly‚Äù style of code that, to me, feels exhausting. My place has always been low-level programming‚Äîin the kernel, at the heart of the system. Where things are more transparent, more direct, and‚Äîat least for me‚Äîeasier to learn.

So I decided to change my focus and my career goals, and this project was born. At first, it was supposed to be a smooth transition from high-level to low-level programming, but the more I planned and the more excited I got, the more I wanted to reconnect with the C language. So I took a leap of faith‚Äîand I don‚Äôt regret it.

I used to think I couldn‚Äôt hyperfocus on a programming project, only after the work had already started. But while planning this project, I experienced one of the strongest hyperfocus episodes I‚Äôve had in years. I was so deep in it I couldn‚Äôt even cook myself something to eat, even though I was hungry, because all my energy and attention were on planning. Honestly, it was a little scary, and I had to make myself regulate my excitement so I could approach this project in a healthy way‚Äîand eat something before I got more dysregulated.

Every moment I‚Äôve spent with this project has been absolutely wonderful and stimulating, even without formally starting to code. I had forgotten that I could feel so excited about my career, and thanks to this, I feel like I‚Äôm recovering a part of myself I thought I had lost.

---

## üîÑ From Android to C: A Natural Transition

Since I decided to explore the world of low-level systems, I knew I wanted to return to C programming. However, at that time, I felt like I was racing against the clock, and spending time reconnecting with the language seemed like a luxury I couldn‚Äôt afford. That‚Äôs why I started with a project in Kotlin, the language I had been using for the past year.

That drive to move quickly led me to turn this project into a native Android app. That way, I wouldn‚Äôt have to deal with running a full project outside the safe environment of Android Studio. Ironically, this decision‚Äîmade under time pressure‚Äîmeant I would now have to spend some of that precious time building a UI.

Initially, I told myself I‚Äôd postpone the UI until I had made progress on the logic, which was what really mattered. I convinced myself that I was excited about the idea of creating an educational app that could help others. But I couldn‚Äôt shake the feeling of unease. The magnitude of this new idea clashed with my need to move fast, and it started to overwhelm me. I felt like Elsa in _Frozen II_, when she hears a voice calling her to something new‚Äîand though she knows she shouldn‚Äôt follow it, the pull is too strong. That‚Äôs how I felt about C. I couldn‚Äôt stop thinking about how well this project would fit if I did it in C, but at the same time, I kept telling myself it would be a waste of time I couldn‚Äôt afford.

Eventually, I gave in and decided to do the project in C. I knew I‚Äôd have to learn new things along the way, and go through processes I find tedious while doing so. Fortunately, I‚Äôve been working on my coping strategies for a while now, so these tasks were less difficult and draining than expected.

I also knew that switching languages from the start would require me to take things slowly. I reminded myself of all the times I tried to rush and ended up leaving behind a trail of half-finished projects. Valuable projects that had shone because of the calm time I had dedicated to them‚Äîbut that I abandoned when the pressure made me feel like I was wasting time and needed to change course again. I reminded myself that I don‚Äôt shine when I run‚ÄîI shine when I take my time.

I‚Äôm a swimmer, but I‚Äôve never liked swimming fast. It exhausts and stresses me. I prefer swimming at a steady pace without stopping; that way, I can take care of my technique, keep my rhythm, and last longer. I‚Äôd rather swim 1 km slowly and nonstop than 50 m at a frantic pace. I think that applies to many areas of my life. As a neurodivergent person, I know I process the world differently and tend to notice things others never even consider. Having this macro view is a huge advantage in terms of quality, but it takes more time and energy to cover all the bases.

A curious fact I‚Äôd like to share is that writing a novel and writing software have more in common than one might think. As both a writer and a programmer, this is becoming increasingly clear to me. If you jump into writing without preparation, all you‚Äôll end up with is a mess. First of all, you need to be clear‚Äîat least partially‚Äîabout what you want to achieve with the project. What parts it includes, what each part will do, and how they‚Äôll interact. You also need to be clear on what _won‚Äôt_ be done. You need to decide the order of things, and how you‚Äôll approach the problem. Once the planning is done, you begin the project knowing full well there may be many changes ahead‚Äîyou have to be ready to adapt. And all of that applies equally whether you‚Äôre writing a story or building software.

It may sound crazy, but when I plan a story, I decouple my characters, the plot, and the world as much as I can, so that if I want to change the entire universe, I can do it easily‚Äîwithout having to restart the whole project. It‚Äôs almost like applying SOLID principles to creative writing. And once I finish writing, I have to edit the manuscript‚Äîor refactor the code. Make sure it‚Äôs readable, that there are no inconsistencies, no dead ends, no redundant elements, and nothing missing.

I bring all this up because, a year or two ago, I learned that I can‚Äôt write a good story unless I give it the proper time and dedication during the planning phase. I have to take my time and not rush, because rushing never leads to anything good. I have to put in the effort. And now I realize that writing and programming aren‚Äôt so different‚Äîand that everything I‚Äôve learned about writing a novel also applies to building a software project.

I also have to remind myself that I can‚Äôt stay in the planning phase forever. At some point, I have to start writing‚Äîand once I‚Äôm done, I need to review everything again to make sure the project is as good as it can be.

This is a project I will give the time and dedication it deserves. A project that continues to evolve each day, because every day I learn something new about it and make important decisions‚Äîeven if I haven‚Äôt started coding formally yet.

---

## üéØ What I Expect From This Project

This project, first and foremost, is my entry point into low-level programming‚Äîand also my personal portfolio. Initially, I planned for it to handle memory management tasks, including storing and reading data in memory‚Äîtasks that belong to other system components. While studying how to implement it, I realized this was a mistake and decided to shift my focus.

Since the project is already called _AllocatorLaboratory_, I decided to stick to just programming allocators: that is, the tasks of allocating and freeing memory. But I also decided I still want to handle full memory management and more, so in the future I‚Äôll be working on a loader and other system components. The ultimate goal is to piece everything together into a small kernel built from all my finished projects.

But I like being organized and doing one thing at a time. So for now, I‚Äôll focus my attention on the allocators.

