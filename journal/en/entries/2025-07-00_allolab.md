# 🌱 The Origin

[⬅️ Back to index](../journal_index.md)  
[🌐 Ver esta entrada en español](../../es/entries/2025-07-00_allolab.es.md)

## 🌱 Discovering Myself Through Allocator Laboratory

I spent a long time trying to break into the job market as an Android developer, but it was always difficult because I struggled to sit down and code, and to look for job openings. Fortunately, little by little, I managed to create a space and a set of strategies that allowed me to move forward. I learned Kotlin and Compose easily, but whenever I faced the challenge of learning a specialized library like Retrofit or Jetpack-MVVM, I would get stuck and avoid it by focusing on other things, like understanding SOLID or learning how to write unit tests. I even learned how to use MVVM as an architecture in an attempt to create a more comfortable foundation from which to approach specialized libraries.

Over time, I realized my struggles came from my need to understand everything in depth. For me, using those libraries felt like trying to work from inside a black box—one I couldn’t use until I had lit up all of its internal components. But most people don’t face it that way: they’re outside the box and can use it without a problem. I changed my learning strategy and made sure I understood everything until I felt satisfied. That change was incredibly nourishing, though I still preferred to consolidate my architectural understanding over learning new libraries.

Recently, I discovered that I’m autistic. This kind of discovery forces you to look inward and reevaluate things you once took as obvious and natural. I realized I had been job hunting with neurotypical strategies that were sabotaging me, and that I had a tendency to undervalue my knowledge just because I didn’t understand it as deeply as I wanted, or because I believed it was too basic or common to even mention. I realized that the invisible force I had to fight every day before I could sit down and work came from a lack of self-awareness—about myself and about my neurotype.

Understanding this forced me to change my approach. In the process, I learned about the executive dysfunctions that are so common in neurodivergent people, and I created strategies to deal with them. This improved my life in many ways and made me more productive. I also realized that, contrary to what I believed, I hadn’t wasted years doing nothing. The tools I built during that time—both technical and personal—are now my greatest professional strengths.

However, when I looked into job openings within neuroinclusion programs, I didn’t find any that fit the profile I thought I had. Thinking I had nothing to lose, I started looking into other roles—and I came across a profile I had completely ruled out before, simply due to a lack of understanding: low-level systems developer.

As I read more about it and did more research, I started getting excited. This wasn’t just a fallback option—it was something genuinely thrilling. I realized that there was a space where I could still program in C, my first programming language, and the one I always felt most comfortable with. I remembered how, during college, I delayed adopting a high-level language for as long as I could—I was simply too comfortable with C. Object-oriented programming had always intimidated me, and I didn’t know why at the time. I could use it just fine, but it never quite felt right.

I also remembered my first semesters in college, when we studied low-level topics that fascinated me and made me fall in love with my degree. But as I advanced, all of that started fading away. One day, I found myself wondering what had made me love computing so much in the first place—wondering where that spark had gone. I even began questioning whether I had chosen the right career.

Now, looking back, I realize that I was never meant for high-level programming, with its black boxes and its seemingly more “friendly” style of code that, to me, feels exhausting. My place has always been low-level programming—in the kernel, at the heart of the system. Where things are more transparent, more direct, and—at least for me—easier to learn.

So I decided to change my focus and my career goals, and this project was born. At first, it was supposed to be a smooth transition from high-level to low-level programming, but the more I planned and the more excited I got, the more I wanted to reconnect with the C language. So I took a leap of faith—and I don’t regret it.

I used to think I couldn’t hyperfocus on a programming project, only after the work had already started. But while planning this project, I experienced one of the strongest hyperfocus episodes I’ve had in years. I was so deep in it I couldn’t even cook myself something to eat, even though I was hungry, because all my energy and attention were on planning. Honestly, it was a little scary, and I had to make myself regulate my excitement so I could approach this project in a healthy way—and eat something before I got more dysregulated.

Every moment I’ve spent with this project has been absolutely wonderful and stimulating, even without formally starting to code. I had forgotten that I could feel so excited about my career, and thanks to this, I feel like I’m recovering a part of myself I thought I had lost.

---

## 🔄 From Android to C: A Natural Transition

Since I decided to explore the world of low-level systems, I knew I wanted to return to C programming. However, at that time, I felt like I was racing against the clock, and spending time reconnecting with the language seemed like a luxury I couldn’t afford. That’s why I started with a project in Kotlin, the language I had been using for the past year.

That drive to move quickly led me to turn this project into a native Android app. That way, I wouldn’t have to deal with running a full project outside the safe environment of Android Studio. Ironically, this decision—made under time pressure—meant I would now have to spend some of that precious time building a UI.

Initially, I told myself I’d postpone the UI until I had made progress on the logic, which was what really mattered. I convinced myself that I was excited about the idea of creating an educational app that could help others. But I couldn’t shake the feeling of unease. The magnitude of this new idea clashed with my need to move fast, and it started to overwhelm me. I felt like Elsa in _Frozen II_, when she hears a voice calling her to something new—and though she knows she shouldn’t follow it, the pull is too strong. That’s how I felt about C. I couldn’t stop thinking about how well this project would fit if I did it in C, but at the same time, I kept telling myself it would be a waste of time I couldn’t afford.

Eventually, I gave in and decided to do the project in C. I knew I’d have to learn new things along the way, and go through processes I find tedious while doing so. Fortunately, I’ve been working on my coping strategies for a while now, so these tasks were less difficult and draining than expected.

I also knew that switching languages from the start would require me to take things slowly. I reminded myself of all the times I tried to rush and ended up leaving behind a trail of half-finished projects. Valuable projects that had shone because of the calm time I had dedicated to them—but that I abandoned when the pressure made me feel like I was wasting time and needed to change course again. I reminded myself that I don’t shine when I run—I shine when I take my time.

I’m a swimmer, but I’ve never liked swimming fast. It exhausts and stresses me. I prefer swimming at a steady pace without stopping; that way, I can take care of my technique, keep my rhythm, and last longer. I’d rather swim 1 km slowly and nonstop than 50 m at a frantic pace. I think that applies to many areas of my life. As a neurodivergent person, I know I process the world differently and tend to notice things others never even consider. Having this macro view is a huge advantage in terms of quality, but it takes more time and energy to cover all the bases.

A curious fact I’d like to share is that writing a novel and writing software have more in common than one might think. As both a writer and a programmer, this is becoming increasingly clear to me. If you jump into writing without preparation, all you’ll end up with is a mess. First of all, you need to be clear—at least partially—about what you want to achieve with the project. What parts it includes, what each part will do, and how they’ll interact. You also need to be clear on what _won’t_ be done. You need to decide the order of things, and how you’ll approach the problem. Once the planning is done, you begin the project knowing full well there may be many changes ahead—you have to be ready to adapt. And all of that applies equally whether you’re writing a story or building software.

It may sound crazy, but when I plan a story, I decouple my characters, the plot, and the world as much as I can, so that if I want to change the entire universe, I can do it easily—without having to restart the whole project. It’s almost like applying SOLID principles to creative writing. And once I finish writing, I have to edit the manuscript—or refactor the code. Make sure it’s readable, that there are no inconsistencies, no dead ends, no redundant elements, and nothing missing.

I bring all this up because, a year or two ago, I learned that I can’t write a good story unless I give it the proper time and dedication during the planning phase. I have to take my time and not rush, because rushing never leads to anything good. I have to put in the effort. And now I realize that writing and programming aren’t so different—and that everything I’ve learned about writing a novel also applies to building a software project.

I also have to remind myself that I can’t stay in the planning phase forever. At some point, I have to start writing—and once I’m done, I need to review everything again to make sure the project is as good as it can be.

This is a project I will give the time and dedication it deserves. A project that continues to evolve each day, because every day I learn something new about it and make important decisions—even if I haven’t started coding formally yet.

---

## 🎯 What I Expect From This Project

This project, first and foremost, is my entry point into low-level programming—and also my personal portfolio. Initially, I planned for it to handle memory management tasks, including storing and reading data in memory—tasks that belong to other system components. While studying how to implement it, I realized this was a mistake and decided to shift my focus.

Since the project is already called _AllocatorLaboratory_, I decided to stick to just programming allocators: that is, the tasks of allocating and freeing memory. But I also decided I still want to handle full memory management and more, so in the future I’ll be working on a loader and other system components. The ultimate goal is to piece everything together into a small kernel built from all my finished projects.

But I like being organized and doing one thing at a time. So for now, I’ll focus my attention on the allocators.

---

> 📝 Originally written in Spanish and translated with AI assistance to preserve meaning and tone as closely as possible.