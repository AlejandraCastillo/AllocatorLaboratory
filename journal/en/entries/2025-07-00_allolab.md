# ğŸŒ± The Origin

[â¬…ï¸ Back to index](../journal_index.md)  
[ğŸŒ Ver esta entrada en espaÃ±ol](../../es/entries/2025-07-00_allolab.es.md)

## ğŸŒ± Discovering Myself Through Allocator Laboratory

I spent a long time trying to break into the job market as an Android developer, but it was always difficult because I struggled to sit down and code, and to look for job openings. Fortunately, little by little, I managed to create a space and a set of strategies that allowed me to move forward. I learned Kotlin and Compose easily, but whenever I faced the challenge of learning a specialized library like Retrofit or Jetpack-MVVM, I would get stuck and avoid it by focusing on other things, like understanding SOLID or learning how to write unit tests. I even learned how to use MVVM as an architecture in an attempt to create a more comfortable foundation from which to approach specialized libraries.

Over time, I realized my struggles came from my need to understand everything in depth. For me, using those libraries felt like trying to work from inside a black boxâ€”one I couldnâ€™t use until I had lit up all of its internal components. But most people donâ€™t face it that way: theyâ€™re outside the box and can use it without a problem. I changed my learning strategy and made sure I understood everything until I felt satisfied. That change was incredibly nourishing, though I still preferred to consolidate my architectural understanding over learning new libraries.

Recently, I discovered that Iâ€™m autistic. This kind of discovery forces you to look inward and reevaluate things you once took as obvious and natural. I realized I had been job hunting with neurotypical strategies that were sabotaging me, and that I had a tendency to undervalue my knowledge just because I didnâ€™t understand it as deeply as I wanted, or because I believed it was too basic or common to even mention. I realized that the invisible force I had to fight every day before I could sit down and work came from a lack of self-awarenessâ€”about myself and about my neurotype.

Understanding this forced me to change my approach. In the process, I learned about the executive dysfunctions that are so common in neurodivergent people, and I created strategies to deal with them. This improved my life in many ways and made me more productive. I also realized that, contrary to what I believed, I hadnâ€™t wasted years doing nothing. The tools I built during that timeâ€”both technical and personalâ€”are now my greatest professional strengths.

However, when I looked into job openings within neuroinclusion programs, I didnâ€™t find any that fit the profile I thought I had. Thinking I had nothing to lose, I started looking into other rolesâ€”and I came across a profile I had completely ruled out before, simply due to a lack of understanding: low-level systems developer.

As I read more about it and did more research, I started getting excited. This wasnâ€™t just a fallback optionâ€”it was something genuinely thrilling. I realized that there was a space where I could still program in C, my first programming language, and the one I always felt most comfortable with. I remembered how, during college, I delayed adopting a high-level language for as long as I couldâ€”I was simply too comfortable with C. Object-oriented programming had always intimidated me, and I didnâ€™t know why at the time. I could use it just fine, but it never quite felt right.

I also remembered my first semesters in college, when we studied low-level topics that fascinated me and made me fall in love with my degree. But as I advanced, all of that started fading away. One day, I found myself wondering what had made me love computing so much in the first placeâ€”wondering where that spark had gone. I even began questioning whether I had chosen the right career.

Now, looking back, I realize that I was never meant for high-level programming, with its black boxes and its seemingly more â€œfriendlyâ€ style of code that, to me, feels exhausting. My place has always been low-level programmingâ€”in the kernel, at the heart of the system. Where things are more transparent, more direct, andâ€”at least for meâ€”easier to learn.

So I decided to change my focus and my career goals, and this project was born. At first, it was supposed to be a smooth transition from high-level to low-level programming, but the more I planned and the more excited I got, the more I wanted to reconnect with the C language. So I took a leap of faithâ€”and I donâ€™t regret it.

I used to think I couldnâ€™t hyperfocus on a programming project, only after the work had already started. But while planning this project, I experienced one of the strongest hyperfocus episodes Iâ€™ve had in years. I was so deep in it I couldnâ€™t even cook myself something to eat, even though I was hungry, because all my energy and attention were on planning. Honestly, it was a little scary, and I had to make myself regulate my excitement so I could approach this project in a healthy wayâ€”and eat something before I got more dysregulated.

Every moment Iâ€™ve spent with this project has been absolutely wonderful and stimulating, even without formally starting to code. I had forgotten that I could feel so excited about my career, and thanks to this, I feel like Iâ€™m recovering a part of myself I thought I had lost.

---

## ğŸ”„ From Android to C: A Natural Transition

Since I decided to explore the world of low-level systems, I knew I wanted to return to C programming. However, at that time, I felt like I was racing against the clock, and spending time reconnecting with the language seemed like a luxury I couldnâ€™t afford. Thatâ€™s why I started with a project in Kotlin, the language I had been using for the past year.

That drive to move quickly led me to turn this project into a native Android app. That way, I wouldnâ€™t have to deal with running a full project outside the safe environment of Android Studio. Ironically, this decisionâ€”made under time pressureâ€”meant I would now have to spend some of that precious time building a UI.

Initially, I told myself Iâ€™d postpone the UI until I had made progress on the logic, which was what really mattered. I convinced myself that I was excited about the idea of creating an educational app that could help others. But I couldnâ€™t shake the feeling of unease. The magnitude of this new idea clashed with my need to move fast, and it started to overwhelm me. I felt like Elsa in _Frozen II_, when she hears a voice calling her to something newâ€”and though she knows she shouldnâ€™t follow it, the pull is too strong. Thatâ€™s how I felt about C. I couldnâ€™t stop thinking about how well this project would fit if I did it in C, but at the same time, I kept telling myself it would be a waste of time I couldnâ€™t afford.

Eventually, I gave in and decided to do the project in C. I knew Iâ€™d have to learn new things along the way, and go through processes I find tedious while doing so. Fortunately, Iâ€™ve been working on my coping strategies for a while now, so these tasks were less difficult and draining than expected.

I also knew that switching languages from the start would require me to take things slowly. I reminded myself of all the times I tried to rush and ended up leaving behind a trail of half-finished projects. Valuable projects that had shone because of the calm time I had dedicated to themâ€”but that I abandoned when the pressure made me feel like I was wasting time and needed to change course again. I reminded myself that I donâ€™t shine when I runâ€”I shine when I take my time.

Iâ€™m a swimmer, but Iâ€™ve never liked swimming fast. It exhausts and stresses me. I prefer swimming at a steady pace without stopping; that way, I can take care of my technique, keep my rhythm, and last longer. Iâ€™d rather swim 1 km slowly and nonstop than 50 m at a frantic pace. I think that applies to many areas of my life. As a neurodivergent person, I know I process the world differently and tend to notice things others never even consider. Having this macro view is a huge advantage in terms of quality, but it takes more time and energy to cover all the bases.

A curious fact Iâ€™d like to share is that writing a novel and writing software have more in common than one might think. As both a writer and a programmer, this is becoming increasingly clear to me. If you jump into writing without preparation, all youâ€™ll end up with is a mess. First of all, you need to be clearâ€”at least partiallyâ€”about what you want to achieve with the project. What parts it includes, what each part will do, and how theyâ€™ll interact. You also need to be clear on what _wonâ€™t_ be done. You need to decide the order of things, and how youâ€™ll approach the problem. Once the planning is done, you begin the project knowing full well there may be many changes aheadâ€”you have to be ready to adapt. And all of that applies equally whether youâ€™re writing a story or building software.

It may sound crazy, but when I plan a story, I decouple my characters, the plot, and the world as much as I can, so that if I want to change the entire universe, I can do it easilyâ€”without having to restart the whole project. Itâ€™s almost like applying SOLID principles to creative writing. And once I finish writing, I have to edit the manuscriptâ€”or refactor the code. Make sure itâ€™s readable, that there are no inconsistencies, no dead ends, no redundant elements, and nothing missing.

I bring all this up because, a year or two ago, I learned that I canâ€™t write a good story unless I give it the proper time and dedication during the planning phase. I have to take my time and not rush, because rushing never leads to anything good. I have to put in the effort. And now I realize that writing and programming arenâ€™t so differentâ€”and that everything Iâ€™ve learned about writing a novel also applies to building a software project.

I also have to remind myself that I canâ€™t stay in the planning phase forever. At some point, I have to start writingâ€”and once Iâ€™m done, I need to review everything again to make sure the project is as good as it can be.

This is a project I will give the time and dedication it deserves. A project that continues to evolve each day, because every day I learn something new about it and make important decisionsâ€”even if I havenâ€™t started coding formally yet.

---

## ğŸ¯ What I Expect From This Project

This project, first and foremost, is my entry point into low-level programmingâ€”and also my personal portfolio. Initially, I planned for it to handle memory management tasks, including storing and reading data in memoryâ€”tasks that belong to other system components. While studying how to implement it, I realized this was a mistake and decided to shift my focus.

Since the project is already called _AllocatorLaboratory_, I decided to stick to just programming allocators: that is, the tasks of allocating and freeing memory. But I also decided I still want to handle full memory management and more, so in the future Iâ€™ll be working on a loader and other system components. The ultimate goal is to piece everything together into a small kernel built from all my finished projects.

But I like being organized and doing one thing at a time. So for now, Iâ€™ll focus my attention on the allocators.

---

> ğŸ“ Originally written in Spanish and translated with AI assistance to preserve meaning and tone as closely as possible.