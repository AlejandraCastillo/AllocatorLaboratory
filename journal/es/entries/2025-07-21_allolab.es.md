# üß± Planeando el primer nivel

[‚¨ÖÔ∏è Volver al √≠ndice](../journal_index.es.md)  
[üåê View this entry in English](../../en/entries/2025-07-21_allolab.md)

## üß± Nivel 1 ‚Äì Alocador de bloques fijos con bitmap

- Bloques de tama√±o fijo (ej. 8B)
- Bitmap para marcar bloques libres/ocupados

Es algo sencillo y directo, pero igualmente lo llevar√© por fases.

---

## üß™ Fase 1: Usar un arreglo de enteros

En esta fase, el bitmap ser√° un arreglo de enteros que se llenar√° solo con los valores 1 y 0. Como protecci√≥n para evitar que se le asignen otros valores, se considerar√° 0 como vac√≠o y cualquier otro valor como ocupado.

El alocador recibir√° el tama√±o del dato a alocar y buscar√° un espacio adecuado en el bitmap. Devolver√° la direcci√≥n en memoria del inicio del bloque libre.

Todo esto se manejar√° en un mismo archivo por simplicidad, y se mantendr√° as√≠ hasta que el primer nivel est√© completo. Cuando llegue el momento de incorporar el segundo nivel, me detendr√© para investigar c√≥mo aplicar los principios de SOLID en desarrollo con C.

Tambi√©n creo que es buena idea pensar en la visualizaci√≥n desde esta fase. As√≠ que trabajar√© en una funci√≥n que muestre en pantalla una interpretaci√≥n gr√°fica del bitmap e imprima los datos importantes, como el tama√±o del dato, el lugar en donde se asignar√°, e incluso mostrar el bitmap como un "antes y despu√©s".

---

## üõ†Ô∏è Implementaci√≥n inicial

 Para asignar un bloque de memoria:
- Recibir la longitud del dato.
- Recorrer el bitmap con un ciclo `for`.
- Buscar bloques contiguos del tama√±o solicitado.
- Retornar la posici√≥n del primer bloque libre compuesto solo por 0s.

### Para liberar la memoria:
- Recibir la direcci√≥n del dato y su tama√±o.
- Localizar directamente su posici√≥n en memoria.
- Establecer en 0 las localidades consecutivas correspondientes al tama√±o total del dato.

### Para imprimir el bitmap antes y despu√©s:
- Usar√© los siguientes caracteres para dibujar el bitmap:
  - Bloque lleno: `‚ñ†` (U+25A0)
  - Bloque vac√≠o: `‚ñ°` (U+25A1)
- Guardar√© una copia del bitmap antes de hacer la operaci√≥n.
- Llamar√© a la funci√≥n correspondiente (esto puedo hacerlo con punteros para que la funci√≥n sea un par√°metro; debo investigar c√≥mo hacerlo).
- Imprimir√© el tama√±o del dato, si se est√° reservando o liberando memoria, y la direcci√≥n en memoria que ocupaba u ocupar√° dicho dato.
- Recorrer√© ambos bitmaps imprimiendo estos s√≠mbolos cuando corresponda.
- Procurar√© hacerlo en forma de matriz para que sea m√°s f√°cil de visualizar.
- Primero imprimir√© una l√≠nea del bitmap anterior, luego har√© un par de tabulaciones, e imprimir√© la l√≠nea del bitmap actualizado.

---

## üîÅ Siguiente paso

Convertir el bitmap en un "verdadero" bitmap.  
En lugar de usar un arreglo de enteros, usar√© un arreglo de bytes (o lo m√°s cercano posible en C). As√≠ lograr√© una simulaci√≥n m√°s fiel a un sistema real.

Creo que en este punto el primer nivel estar√° completado, aunque debo investigar m√°s para estar completamente segura.

Siendo ese el caso, este ser√≠a tambi√©n el mejor momento para integrar las primeras pruebas unitarias. Por lo tanto, deber√© tomarme un tiempo para aprender a implementarlas. S√© c√≥mo hacerlas, pero en desarrollo Android, por lo que espero que aprender a implementarlas en este entorno no sea complicado.

---

## üìù Nota personal

Hoy com√≠ mientras trabajaba. Llevo a√±os sin hacer eso porque creo que es horrible no disfrutar de tu hora de comida.  
Pero si me sentaba a comer sin trabajar, no pod√≠a disfrutarla. As√≠ que lo hice trabajando, y la comida estuvo deliciosa.

Realmente me sorprende c√≥mo son mis hiperfocos con este proyecto. Esa es la se√±al de que el cambio de enfoque fue la decisi√≥n correcta.
