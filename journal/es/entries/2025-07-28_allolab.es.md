# ğŸ§  Mientras programo: liberando memoria

[â¬…ï¸ Volver al Ã­ndice](../journal_index.es.md)  
[ğŸŒ View this entry in English](../../en/entries/2025-07-23_allolab.md)

## ğŸ› ï¸ El plan

Creo que esta parte es en realidad sencilla. Como aÃºn estamos en el primer nivel, me tomarÃ© la libertad de recibir el tamaÃ±o del dato de una fuente externa (es decir, como parÃ¡metro de la funciÃ³n), pero sÃ© que eventualmente tendrÃ© que manejarlo de forma distinta.

En este caso, la funciÃ³n solo recibe la direcciÃ³n y el tamaÃ±o. Mediante un ciclo `for`, recorre el bitmap desde la direcciÃ³n dada hasta completar el dato, reemplazando los 1s por 0s.

Este plan es justo lo que harÃ© en esta ocasiÃ³n, pero de una vez anotarÃ© algunas consideraciones que deberÃ­a tener y, de paso, tambiÃ©n algunas consideraciones para la asignaciÃ³n de memoria, ya que el dÃ­a que hice esa funciÃ³n no tenÃ­a energÃ­a para detenerme en este paso.

## ğŸ“Œ Consideraciones

### ... al asignar memoria

- Â¿QuÃ© pasa si el espacio que se desea reservar es mayor que el mismo bitmap?
- Â¿QuÃ© pasa si el espacio a reservar es un nÃºmero negativo?

Ambos hay que comprobarlos como primer paso en la funciÃ³n.

### ... al liberar memoria

- Â¿QuÃ© pasa si la direcciÃ³n no es realmente el inicio de un dato?
- Â¿QuÃ© pasa si el tamaÃ±o no es correcto y terminamos borrando menos o mÃ¡s del dato?
  - Â¿Y si con esa direcciÃ³n y ese tamaÃ±o, llegamos al final del bitmap antes de terminar?
- Â¿Y si el bloque, o parte de Ã©l, ya estÃ¡ libre?

### Conclusiones

Creo que, al final de cuentas, tendrÃ© que incluir un medio para almacenar las direcciones que son el inicio de un dato y el tamaÃ±o de dicho dato. EmpezarÃ© programando la versiÃ³n sencilla con el tamaÃ±o del dato como parÃ¡metro, pero mi siguiente paso serÃ¡ almacenar el tamaÃ±o y la direcciÃ³n como metadatos para el alocador.

