# üß† Mientras programo: tabla de asignaciones

[‚¨ÖÔ∏è Volver al √≠ndice](../journal_index.es.md)  
[üåê View this entry in English](../../en/entries/2025-07-29_allolab.md)

## ü§î Divagando

Hoy vamos a ver la forma de almacenar los metadatos de las direcciones ocupadas y del tama√±o del dato alojado en ellas.

La idea es crear una lista tipo mapa (s√© que no hay mapas en C, pero con una estructura se puede lograr algo similar) donde guarde la tabla de asignaciones ocupadas con sus respectivos tama√±os. As√≠ tengo conciencia de d√≥nde inicia un dato y hasta d√≥nde llega, y por ende evito borrar datos incompletos. Si borro un dato, podr√≠a setear la direcci√≥n en el arreglo como -1.

Tambi√©n pensaba en tener una funci√≥n encargada de actualizar esta tabla de asignaciones, borrar las que est√©n en desuso y reordenar todo, porque entiendo que en C no puedo simplemente borrar algo que est√° al centro de un array.

Y podr√≠a usar este m√©todo de marcar una direcci√≥n como inv√°lida (por ejemplo, con -1) como se√±al de que no hay nada ah√≠, y luego usar la funci√≥n de limpieza solo cuando el arreglo se llene. De esta forma, no se estar√≠an haciendo tantos movimientos constantemente.

Aunque pens√°ndolo bien, creo que las nuevas direcciones deber√≠an guardarse en los espacios que dejaron las viejas.

Entonces, creo que lo mejor ser√° guardar tres datos:

* La direcci√≥n
* El tama√±o del dato
* Si este espacio en la tabla de asignaciones est√° ocupado

El √∫ltimo no se refiere al bitmap, sino espec√≠ficamente a la tabla de asignaciones. As√≠, cuando se desocupe un espacio, solo debo marcarlo como libre, y de esta forma no tengo que borrar nada. Cuando se necesite registrar una nueva direcci√≥n, busco el primer espacio libre para guardar los nuevos datos.

## üõ†Ô∏è El plan

Voy a crear una estructura de datos para almacenar la direcci√≥n, el tama√±o del dato y si est√° ocupado o no. Luego crear√© un array de esa estructura y le dar√© como tama√±o m√°ximo el tama√±o del bitmap (considerando la posibilidad de que cada dato almacenado solo ocupe una celda del bitmap).

Despu√©s debo modificar `allocate_block()` para que, antes de devolver la direcci√≥n de memoria, busque un espacio libre en la tabla de asignaciones y guarde en ella la direcci√≥n y el tama√±o del dato.

Tambi√©n deber√© modificar `free_block()` para que ya no reciba el tama√±o del dato. Al arrancar la funci√≥n:

* Primero se asegurar√° de que la direcci√≥n exista, es decir, que se encuentre entre 0 y el tama√±o del bitmap.
* Si no es as√≠, se arroja un error.
* Luego se buscar√° en la tabla de asignaciones.
* Si no se encuentra, se arroja un error, porque significa que no hay un dato ocupando esa direcci√≥n.
* Se comprueba si est√° ‚Äúocupada‚Äù.
* Si no lo est√°, entonces se arroja un error.
* Si est√° ocupada, se obtiene el tama√±o del dato.
* Se libera la memoria en el bitmap como ya lo hacemos.
* Finalmente, se marca ese espacio en la lista como libre.

## üìå Consideraciones

### ... al asignar memoria

* ¬øQu√© pasa si el espacio que se desea reservar es mayor que el mismo bitmap?
* ¬øQu√© pasa si el espacio a reservar es un n√∫mero negativo?

Ambos hay que comprobarlos como primer paso en la funci√≥n.

### ... al liberar memoria

* Si ya obtenemos un tama√±o guardado por el sistema, ¬øa√∫n debemos verificar que sea coherente?

## üìù Notas

* Al obtener el tama√±o de una direcci√≥n guardada, tambi√©n estamos validando que la direcci√≥n est√© guardada y ocupada.
* Podr√≠a tener la misma direcci√≥n almacenada m√°s de una vez como desocupada, as√≠ que hay que revisar todo el arreglo pese a encontrarla solo una vez.
* Hay muchas comprobaciones de error que tal vez no sean necesarias...

## üîß Planes

* Ya va siendo tiempo de separar el c√≥digo en diversos archivos.
